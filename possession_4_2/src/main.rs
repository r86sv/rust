#![allow(unused)]
/// Язык программирования Rust
/// 4.0 Понимание владения
/// 4.2 Ссылки и заимствование

/// Правила работы с ссылками:
/// В любой момент времени у вас может быть одна (но не обе) изменяемая ссылка или любое количество неизменяемых ссылок.
/// Все ссылки должны быть действительными. 

/// Главная функция программы.
///
/// Эта функция демонстрирует работу с неизменяемыми и изменяемыми ссылками в Rust.
/// Сначала создается неизменяемая строка `s1`, для которой вычисляется длина с помощью функции `calculate_length`.
/// Затем создается изменяемая строка `s2`, которая модифицируется функцией `change_string`.
/// Результаты выводятся на экран.
///
/// В конце демонстрируется создание изменяемой ссылки в отдельном блоке, позволяя создать новую изменяемую ссылку
/// на ту же строку после выхода первой ссылки из области видимости, что соответствует правилам заимствования Rust.
fn main() {
    let s1 = String::from("Привет Rust!");

    let len = calculate_length(&s1);
    println!("Строка \"{}\" занимает {} байт.", s1, len);
    println!();

    let mut s2 = String::from("Привет");
    change_string(&mut s2);
    println!("Строка \"{}\" занимает {} байт.", s2, calculate_length(&s2));
    println!();

    let mut s3 = String::from("Привет");
    {
        // Создание изменяемой ссылки в отдельном блоке
        let r1 = &mut s3;
        // r1 выходит из области видимости здесь, позволяя повторное заимствование `s3`
    }
    // Создание новой изменяемой ссылки после выхода предыдущей ссылки из области видимости
    let r2 = &mut s3;

    let mut s = String::from("Привет");
    let r1 = &s; // Первая неизменяемая ссылка на `s`
    let r2 = &s; // Вторая неизменяемая ссылка на `s`, демонстрирующая возможность множественного заимствования для чтения
    println!("{} {}", r1, r2);
    // Создание изменяемой ссылки `r3` на `s`, после того как неизменяемые ссылки вышли из области видимости
    let r3 = &mut s;
    

    let reference_to_nothing = no_dangle();
}

/// Вычисляет длину данной строки.
///
/// Принимает строку `s` в виде неизменяемой ссылки, что позволяет использовать строку без ее перемещения.
/// Это полезно для чтения значения строки без взятия ее владения.
///
/// # Параметры
///
/// * `s` - Неизменяемая ссылка на строку `String`, длину которой необходимо вычислить.
///
/// # Возвращаемое значение
///
/// Возвращает размер строки в байтах (количество символов) в виде `usize`.
///
/// # Примеры
///
/// ```
/// let my_string = String::from("Привет");
/// let length = calculate_length(&my_string);
/// println!("Длина строки: {}", length); // Выведет: Длина строки: 6
/// ```
fn calculate_length(s: &String) -> usize {
    // s ссылается не String
    s.len()
} // Здесь s выходит за рамки действия. Но поскольку s не владеет тем, на что ссылается, она не удаляется.

/// Изменяет переданную строку, добавляя к ней фразу " мир!".
///
/// Принимает строку `s` в виде изменяемой ссылки, что позволяет модифицировать исходную строку.
/// Это демонстрирует возможность изменения значения, на которое ссылается ссылка, при условии,
/// что ссылка является изменяемой.
///
/// # Параметры
///
/// * `s` - Изменяемая ссылка на строку `String`, которую необходимо изменить.
///
/// # Примеры
///
/// ```
/// let mut my_string = String::from("Привет");
/// change_string(&mut my_string);
/// println!("Измененная строка: {}", my_string); // Выведет: Измененная строка: Привет мир!
/// ```
fn change_string(s: &mut String) {
    s.push_str(" мир!");
}

/// Возвращает строку без риска "висячих" ссылок.
///
/// Эта функция демонстрирует безопасный способ возвращения строки из функции без создания "висячих" ссылок.
/// "Висячие" ссылки возникают, когда функция возвращает ссылку на данные, которые выходят из области видимости
/// и удаляются, что может привести к неопределенному поведению. Возвращая данные напрямую, мы избегаем этой проблемы.
///
/// # Возвращаемое значение
///
/// Возвращает объект `String`, содержащий приветствие.
///
/// # Примеры
///
/// ```
/// let greeting = no_dangle();
/// println!("{}", greeting); // Выведет: Привет Rust!
/// ```
fn no_dangle() -> String {
    let s = String::from("Привет Rust!");

    s
}

/// Демонстрирует ошибку компиляции при попытке создать две изменяемые ссылки на одну и ту же переменную.
///
/// В Rust, создание двух изменяемых ссылок на одну и ту же переменную в одной и той же области видимости
/// недопустимо из-за правил безопасности памяти. Этот пример показывает, как Rust предотвращает возможные
/// ошибки во время компиляции, обеспечивая безопасность работы с памятью.
///
/// # Примеры
///
/// ```
/// // Этот код вызовет ошибку компиляции, так как пытается создать две изменяемые ссылки на одну переменную:
/// let mut s = String::from("hello");
/// let r1 = &mut s;
/// let r2 = &mut s; // Ошибка!
/// println!("{}, {}", r1, r2);
/// ```
fn void0() {}

/// Демонстрирует ошибку компиляции при попытке создать неизменяемые и изменяемую ссылки на одну и ту же переменную.
///
/// В Rust одновременное существование неизменяемых и изменяемой ссылок на одну и ту же переменную недопустимо,
/// так как это может привести к состоянию гонки данных. Этот пример показывает, как Rust предотвращает такие ситуации
/// на этапе компиляции, обеспечивая безопасность памяти и предотвращая возможные ошибки.
///
/// # Пример
///
/// ```
/// let mut s = String::from("Привет!");
/// Демонстрация создания неизменяемых ссылок на строку
/// let r1 = &s; // Первая неизменяемая ссылка
/// let r2 = &s; // Вторая неизменяемая ссылка
///
/// Попытка создать изменяемую ссылку при наличии неизменяемых ссылок
/// let r3 = &mut s; // Изменяемая ссылка
/// println!("{}, {}, and {}", r1, r2, r3);
/// ```
///
/// В данном примере попытка создать `r3` как изменяемую ссылку на `s`, при уже существующих неизменяемых ссылках `r1` и `r2`,
/// приведет к ошибке компиляции. Это демонстрирует строгие правила заимствования Rust, направленные на обеспечение безопасности работы с памятью.
fn void1() {}

/// Создает "висячую" ссылку, что является ошибкой.
///
/// Эта функция демонстрирует пример создания "висячей" ссылки в Rust, что приводит к ошибке компиляции.
/// "Висячая" ссылка возникает, когда функция возвращает ссылку на переменную, которая выходит из области видимости
/// и удаляется, оставляя ссылку без валидного значения на который она указывает.
///
/// # Возвращаемое значение
///
/// Возвращает ссылку на строку `String`, которая будет невалидной при попытке использования.
///
/// # Примеры
///
/// ```
/// let reference_to_nothing = dangle();
/// ```
///
/// # Примечания
///
/// Этот код не скомпилируется из-за ошибки "висячей" ссылки.
/// ```
///fn dangle() -> &String {
///    let s = String::from("hello");
///
///    &s
///}
/// ```
fn void2() {}
