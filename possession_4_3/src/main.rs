#![allow(unused)]
/// Язык программирования Rust
/// 4.0 Понимание владения
/// 4.3 Тип срезы
/// 
/// В Rust это <let s = "Hello, world!";> срез!

fn main() {
    // Создаём новую строку `s`.
    let mut s = String::from("Текст из шести слов разделённых пробелами.");

    // Получаем индекс первого пробела в строке `s` с помощью функции `first_world`.
    let world = first_world(&s);
    // Очищаем строку `s`, делая её пустой.
    s.clear();

    // После очистки `s`, значение `world` становится недействительным.

    // Создаём новую строку `s`.
    let mut s = String::from("hello world");
    // Создаём срезы `hello` и `world`, представляющие подстроки "hello" и "world" соответственно.
    let hello = &s[0..5];
    let world = &s[6..11];

    // Создаём новую строку `s`.
    let s = String::from("hello");
    // Создаём срез `slice`, представляющий подстроку "he".
    let slice = &s[0..2];
    // То же самое, что и предыдущий срез, но используется сокращённая запись.
    let slice = &s[..2];

    // Создаём новую строку `s`.
    let s = String::from("hello");
    // Получаем длину строки `s`.
    let len = s.len();
    // Создаём срез `slice`, представляющий подстроку "lo".
    let slice = &s[3..len];
    // То же самое, что и предыдущий срез, но используется сокращённая запись.
    let slice = &s[3..];

    // Создаём новую строку `s`.
    let s = String::from("hello");
    // Получаем длину строки `s`.
    let len = s.len();
    // Создаём срез `slice`, представляющий всю строку `s`.
    let slice = &s[0..len];
    // То же самое, что и предыдущий срез, но используется сокращённая запись.
    let slice = &s[..];

    let mut s = String::from("Текст из шести слов разделённых пробелами.");
    let world = first_world_1(&s);
    //  s.clear(); // Срезы делают эту ошибку невозможной и сообщают нам о проблеме с нашим кодом гораздо раньше.
    // Так, использование версии метода first_word со срезом вернёт ошибку компиляции:
    println!("Слово = {}", world);

    let my_string = String::from("hello world");
    // `first_word` работает со срезами `String`, будь то частичные или целые
    let word = first_word_2(&my_string[0..6]);
    let word = first_word_2(&my_string[..]);
    // `first_word` также работает со ссылками на `String`, которые эквивалентны
    // целым срезам `String`
    let word = first_word_2(&my_string);

    let my_string_literal = "hello world";
    // `first_word` работает со срезами строковых литералов, будь то частичные или целые
    let word = first_word_2(&my_string_literal[0..6]);
    let word = first_word_2(&my_string_literal[..]);
    // Поскольку строковые литералы *являются* срезами строк,
    // это также работает без синтаксиса среза!
    let word = first_word_2(my_string_literal);
}

/// Находит индекс первого пробела в строке.
///
/// Эта функция принимает ссылку на `String` в качестве параметра и возвращает индекс первого найденного
/// пробела в строке. Если пробел не найден, возвращает длину строки, что фактически указывает на то,
/// что вся строка является одним словом или она пуста.
///
/// # Параметры
/// - `s`: Ссылка на `String`, в котором осуществляется поиск.
///
/// # Возвращает
/// - `usize`, представляющий индекс первого пробела, если он найден, или длину строки, если нет.
///
/// # Примеры
/// ```
/// let sentence = String::from("Привет мир");
/// let index = first_world(&sentence);
/// assert_eq!(index, 6); // Индекс первого пробела в "Привет мир"
/// ```
fn first_world(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}

/// Находит первое слово в строке.
///
/// Эта функция принимает ссылку на `String` и возвращает срез, указывающий на первое слово в строке.
/// Слово определяется как последовательность символов, не содержащая пробелов, и находится до первого пробела в строке.
/// Если пробел в строке не найден, возвращается вся строка.
///
/// # Параметры
/// - `s`: Ссылка на `String`, в котором осуществляется поиск.
///
/// # Возвращает
/// - Срез `&str`, указывающий на первое слово в строке. Если пробел не найден, возвращает весь `String` как срез.
///
/// # Примеры
/// ```
/// let sentence = String::from("Привет мир");
/// let word = first_world_1(&sentence);
/// assert_eq!(word, "Привет"); // Первое слово в "Привет мир"
/// ```
fn first_world_1(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[..i];
        }
    }

    &s[..]
}

/// Находит первое слово в строке, используя срезы.
///
/// Эта функция принимает строку в качестве параметра и возвращает срез, указывающий на первое слово.
/// Слово определяется как последовательность символов до первого пробела. Если пробел не найден,
/// возвращается весь входной срез.
///
/// # Параметры
/// - `s`: Ссылка на строку `&str`, в которой осуществляется поиск.
///
/// # Возвращает
/// - Срез `&str`, указывающий на первое слово. Если пробел не найден, возвращает весь входной срез.
///
/// # Примеры
/// ```
/// let sentence = "Привет мир";
/// let word = first_word_2(sentence);
/// assert_eq!(word, "Привет"); // Первое слово в "Привет мир"
/// ```
fn first_word_2(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
